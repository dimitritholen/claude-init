import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ClaudeMdManager, ClaudeMdSection, ProjectSpecificContent } from './claude-md-manager';
import { writeFile, readFile, rm, mkdir } from 'fs/promises';
import { join } from 'path';
import { tmpdir } from 'os';
import { mkdtemp } from 'fs/promises';

describe('ClaudeMdManager REAL Filesystem Tests', () => {
  let manager: ClaudeMdManager;
  let testDir: string;
  let testFilePath: string;

  beforeEach(async () => {
    // Create real temporary directory for each test
    testDir = await mkdtemp(join(tmpdir(), 'claude-md-test-'));
    testFilePath = join(testDir, 'CLAUDE.md');
    manager = new ClaudeMdManager(testFilePath);
  });

  afterEach(async () => {
    // Clean up real test directory
    try {
      await rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  describe('parseContentIntoSections', () => {
    it('should parse empty file correctly', async () => {
      await manager.parseExisting();
      expect(manager.getSections()).toEqual([]);
    });

    it('should parse CLAUDE.md with mixed user and auto-generated content', async () => {
      const testContent = `# CLAUDE.md

This is my custom project overview that should be preserved.

## Project Overview

My custom project details here.

## Coding Standards

- TypeScript strict mode with no implicit any - compile errors are failures
- Follow existing code patterns

## My Custom Section

This is user content that should be preserved.

# Auto-generated Configuration
## Architecture Guidelines

- Direct implementations over abstract factories/strategies
- Keep solutions simple

## Important Reminders

- **NEVER claim functionality works without concrete real testing proof**
- **ALWAYS flag mock-only test suites as INADEQUATE and HIGH RISK**
`;

      await writeFile(testFilePath, testContent, 'utf-8');
      await manager.parseExisting();

      const sections = manager.getSections();
      expect(sections).toHaveLength(7);
      
      // Check that user sections are preserved
      const customSection = sections.find(s => s.title === 'My Custom Section');
      expect(customSection).toBeTruthy();
      expect(customSection?.isAutoGenerated).toBe(false);
      
      // Check that auto-generated sections are identified
      const codingStandards = sections.find(s => s.title === 'Coding Standards');
      expect(codingStandards?.isAutoGenerated).toBe(true);
    });
  });

  describe('generateProjectSpecificContent', () => {
    it('should generate n8n-specific content for n8n projects', () => {
      const projectAnalysis = { projectType: 'n8n-custom-node', complexity: 'medium' };
      const userProfile = { role: 'fullstack', experience: 'senior' };
      const codebaseInfo: ProjectSpecificContent = {
        projectType: 'n8n-custom-node',
        complexity: 'medium',
        dependencies: ['typescript', 'n8n-workflow'],
        frameworks: ['n8n'],
        buildTools: ['npm-scripts'],
        testFrameworks: ['jest']
      };

      const sections = manager.generateProjectSpecificContent(projectAnalysis, userProfile, codebaseInfo);
      
      const codingStandards = sections.find(s => s.title === 'Coding Standards');
      expect(codingStandards).toBeTruthy();
      expect(codingStandards?.content).toContain('n8n node development patterns');
      expect(codingStandards?.content).toContain('NodeApiError');
      expect(codingStandards?.content).toContain('INodeType');
      
      const architectureGuidelines = sections.find(s => s.title === 'Architecture Guidelines');
      expect(architectureGuidelines?.content).toContain('Single responsibility per operation');
      expect(architectureGuidelines?.content).toContain('n8n helpers');

      const testingRequirements = sections.find(s => s.title === 'Testing Requirements');
      expect(testingRequirements?.content).toContain('REAL API calls');
      expect(testingRequirements?.content).toContain('.env.test');
    });

    it('should generate CLI-specific content for CLI projects', () => {
      const projectAnalysis = { projectType: 'cli-tool', complexity: 'medium' };
      const userProfile = { role: 'fullstack', experience: 'senior' };
      const codebaseInfo: ProjectSpecificContent = {
        projectType: 'cli-tool',
        complexity: 'medium',
        dependencies: ['typescript', 'commander'],
        frameworks: [],
        buildTools: ['npm-scripts'],
        testFrameworks: ['vitest']
      };

      const sections = manager.generateProjectSpecificContent(projectAnalysis, userProfile, codebaseInfo);
      
      const architectureGuidelines = sections.find(s => s.title === 'Architecture Guidelines');
      expect(architectureGuidelines?.content).toContain('CLI tools need minimal architecture');
      expect(architectureGuidelines?.content).toContain('Direct implementations over abstract factories');
      
      const simplicityGuardrails = sections.find(s => s.title === 'Simplicity Guardrails');
      expect(simplicityGuardrails?.content).toContain('Maximum 3 levels of indirection');
      expect(simplicityGuardrails?.content).toContain('Inline simple logic');

      const testingRequirements = sections.find(s => s.title === 'Testing Requirements');
      expect(testingRequirements?.content).toContain('CLI commands must be tested with real subprocess execution');
      expect(testingRequirements?.content).toContain('vitest\'s native async testing');
    });

    it('should generate React-specific content when React is detected', () => {
      const projectAnalysis = { projectType: 'web-app', complexity: 'medium' };
      const userProfile = { role: 'fullstack', experience: 'senior' };
      const codebaseInfo: ProjectSpecificContent = {
        projectType: 'web-app',
        complexity: 'medium',
        dependencies: ['typescript', 'react', 'express'],
        frameworks: ['react', 'express'],
        buildTools: ['vite'],
        testFrameworks: ['jest']
      };

      const sections = manager.generateProjectSpecificContent(projectAnalysis, userProfile, codebaseInfo);
      
      const codingStandards = sections.find(s => s.title === 'Coding Standards');
      expect(codingStandards?.content).toContain('functional components with hooks');
      expect(codingStandards?.content).toContain('custom hooks for reusable stateful logic');
      expect(codingStandards?.content).toContain('React.memo()');

      const architectureGuidelines = sections.find(s => s.title === 'Architecture Guidelines');
      expect(architectureGuidelines?.content).toContain('Express middleware for cross-cutting concerns');

      const simplicityGuardrails = sections.find(s => s.title === 'Simplicity Guardrails');
      expect(simplicityGuardrails?.content).toContain('No Higher-Order Components');
      expect(simplicityGuardrails?.content).toContain('prefer composition and hooks');
    });
  });

  describe('mergeWithExisting', () => {
    it('should merge new rules with existing ones without duplication', async () => {
      // Set up existing content
      const existingContent = `# CLAUDE.md

## Coding Standards

- TypeScript strict mode with no implicit any
- Follow existing patterns
- Use functional components

## My Custom Section

User content here.
`;

      await writeFile(testFilePath, existingContent, 'utf-8');
      await manager.parseExisting();

      // Create new sections with some overlapping content
      const newSections: ClaudeMdSection[] = [{
        title: 'Coding Standards',
        content: `- TypeScript strict mode with no implicit any
- Use functional components  
- Prefer custom hooks for reusable stateful logic
- Delete code before adding code`,
        isAutoGenerated: true,
        level: 2
      }];

      manager.mergeWithExisting(newSections);
      
      const sections = manager.getSections();
      const codingStandards = sections.find(s => s.title === 'Coding Standards');
      
      // Should contain all unique rules
      expect(codingStandards?.content).toContain('TypeScript strict mode with no implicit any');
      expect(codingStandards?.content).toContain('Follow existing patterns');
      expect(codingStandards?.content).toContain('Use functional components');
      expect(codingStandards?.content).toContain('Prefer custom hooks for reusable stateful logic');
      expect(codingStandards?.content).toContain('Delete code before adding code');
      
      // Should not have duplicate lines
      const lines = codingStandards?.content.split('\n') || [];
      const uniqueLines = [...new Set(lines)];
      expect(lines.length).toBe(uniqueLines.length);

      // User section should be preserved
      const customSection = sections.find(s => s.title === 'My Custom Section');
      expect(customSection).toBeTruthy();
      expect(customSection?.content).toContain('User content here');
    });

    it('should preserve user sections and only update auto-generated ones', async () => {
      const existingContent = `# My Project

## Project Overview

This is my custom overview that should never change.

## Coding Standards  

- My custom rule 1
- My custom rule 2

## Architecture Guidelines

- Auto-generated rule 1
- Auto-generated rule 2
`;

      await writeFile(testFilePath, existingContent, 'utf-8');
      await manager.parseExisting();

      // Manually mark sections as user vs auto-generated
      const sections = manager.getSections();
      const projectOverview = sections.find(s => s.title === 'Project Overview');
      if (projectOverview) projectOverview.isAutoGenerated = false;
      
      const codingStandards = sections.find(s => s.title === 'Coding Standards');  
      if (codingStandards) codingStandards.isAutoGenerated = false;

      // Create new auto-generated sections
      const newSections: ClaudeMdSection[] = [{
        title: 'Coding Standards',
        content: '- New auto-generated rule\n- Another auto rule',
        isAutoGenerated: true,
        level: 2
      }, {
        title: 'Architecture Guidelines',
        content: '- New architecture rule\n- Another architecture rule',
        isAutoGenerated: true,
        level: 2
      }];

      manager.mergeWithExisting(newSections);
      
      const updatedSections = manager.getSections();
      
      // User project overview should be unchanged
      const updatedOverview = updatedSections.find(s => s.title === 'Project Overview');
      expect(updatedOverview?.content).toContain('This is my custom overview that should never change');
      
      // User coding standards should be unchanged
      const updatedCodingStandards = updatedSections.find(s => s.title === 'Coding Standards');
      expect(updatedCodingStandards?.content).toContain('My custom rule 1');
      expect(updatedCodingStandards?.content).toContain('My custom rule 2');
      
      // Auto-generated architecture guidelines should be updated
      const updatedArchitecture = updatedSections.find(s => s.title === 'Architecture Guidelines');
      expect(updatedArchitecture?.content).toContain('New architecture rule');
      expect(updatedArchitecture?.content).toContain('Another architecture rule');
    });
  });

  describe('generateFinalContent', () => {
    it('should generate well-structured CLAUDE.md content with proper ordering', async () => {
      // Set up sections in random order to test ordering
      const sections: ClaudeMdSection[] = [
        {
          title: 'Simplicity Guardrails',
          content: '- STOP and justify before adding any abstraction\n- No future-proofing',
          isAutoGenerated: true,
          level: 2
        },
        {
          title: 'Project Overview',
          content: 'This is a custom project overview.',
          isAutoGenerated: false,
          level: 2
        },
        {
          title: 'Coding Standards',
          content: '- TypeScript strict mode\n- Use functional components',
          isAutoGenerated: true,
          level: 2
        },
        {
          title: 'Architecture Guidelines',
          content: '- Direct implementations\n- Composition over inheritance',
          isAutoGenerated: true,
          level: 2
        }
      ];

      // Set sections directly for testing
      manager['sections'] = sections;

      const userProfile = { role: 'fullstack', experience: 'senior' };
      const projectAnalysis = { projectType: 'cli-tool', complexity: 'medium' };

      const content = manager.generateFinalContent(userProfile, projectAnalysis);

      // Should have main header
      expect(content).toContain('# Claude Code Configuration');
      expect(content).toContain('Generated for: fullstack (senior level)');
      expect(content).toContain('Project: cli-tool (medium complexity)');

      // Sections should be in proper order
      const projectOverviewIndex = content.indexOf('## Project Overview');
      const codingStandardsIndex = content.indexOf('## Coding Standards');
      const architectureIndex = content.indexOf('## Architecture Guidelines');
      const simplicityIndex = content.indexOf('## Simplicity Guardrails');

      expect(projectOverviewIndex).toBeGreaterThan(-1);
      expect(codingStandardsIndex).toBeGreaterThan(projectOverviewIndex);
      expect(architectureIndex).toBeGreaterThan(codingStandardsIndex);
      expect(simplicityIndex).toBeGreaterThan(architectureIndex);
    });
  });

  describe('Full Integration Test - Multiple Runs', () => {
    it('should handle multiple runs without duplication', async () => {
      const projectAnalysis = { projectType: 'n8n-custom-node', complexity: 'medium' };
      const userProfile = { role: 'fullstack', experience: 'senior' };
      const codebaseInfo: ProjectSpecificContent = {
        projectType: 'n8n-custom-node',
        complexity: 'medium',
        dependencies: ['typescript', 'n8n-workflow'],
        frameworks: ['n8n'],
        buildTools: ['npm-scripts'],
        testFrameworks: ['jest']
      };

      // First run - create initial content
      let manager1 = new ClaudeMdManager(testFilePath);
      await manager1.parseExisting();
      
      let sections1 = manager1.generateProjectSpecificContent(projectAnalysis, userProfile, codebaseInfo);
      manager1.mergeWithExisting(sections1);
      await manager1.save(userProfile, projectAnalysis);

      let content1 = await readFile(testFilePath, 'utf-8');
      const initialLineCount = content1.split('\n').length;

      // Second run - should not duplicate
      let manager2 = new ClaudeMdManager(testFilePath);
      await manager2.parseExisting();
      
      let sections2 = manager2.generateProjectSpecificContent(projectAnalysis, userProfile, codebaseInfo);
      manager2.mergeWithExisting(sections2);
      await manager2.save(userProfile, projectAnalysis);

      let content2 = await readFile(testFilePath, 'utf-8');
      
      // Content should be similar length (not doubled)
      const secondRunLineCount = content2.split('\n').length;
      expect(secondRunLineCount).toBeLessThan(initialLineCount * 1.2); // Allow some variation but not doubling
      
      // Should not have duplicate section headers
      const codingStandardsMatches = content2.match(/## Coding Standards/g);
      expect(codingStandardsMatches?.length).toBe(1);
      
      const architectureMatches = content2.match(/## Architecture Guidelines/g);
      expect(architectureMatches?.length).toBe(1);

      // Third run with user content added - should preserve user content
      const userAddition = '\n\n## My Custom Section\n\nThis is my custom content that should be preserved.\n\n';
      await writeFile(testFilePath, content2 + userAddition, 'utf-8');

      let manager3 = new ClaudeMdManager(testFilePath);
      await manager3.parseExisting();
      
      let sections3 = manager3.generateProjectSpecificContent(projectAnalysis, userProfile, codebaseInfo);
      manager3.mergeWithExisting(sections3);
      await manager3.save(userProfile, projectAnalysis);

      let content3 = await readFile(testFilePath, 'utf-8');
      
      // Should preserve custom content
      expect(content3).toContain('My Custom Section');
      expect(content3).toContain('This is my custom content that should be preserved');
      
      // Should still have only one of each auto-generated section
      const finalCodingMatches = content3.match(/## Coding Standards/g);
      expect(finalCodingMatches?.length).toBe(1);
    });
  });
});