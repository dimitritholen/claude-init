import { readFile, writeFile } from 'fs/promises';
import { existsSync } from 'fs';

export interface ClaudeMdSection {
  title: string;
  content: string;
  isAutoGenerated: boolean;
  level: number; // 1 for #, 2 for ##, etc.
}

export interface ProjectSpecificContent {
  projectType: string;
  complexity: string;
  dependencies: string[];
  frameworks: string[];
  buildTools: string[];
  testFrameworks: string[];
}

export class ClaudeMdManager {
  private filePath: string;
  private sections: ClaudeMdSection[] = [];

  constructor(filePath: string) {
    this.filePath = filePath;
  }

  /**
   * Parse existing CLAUDE.md file into structured sections
   */
  async parseExisting(): Promise<void> {
    if (!existsSync(this.filePath)) {
      this.sections = [];
      return;
    }

    const content = await readFile(this.filePath, 'utf-8');
    this.sections = this.parseContentIntoSections(content);
  }

  private parseContentIntoSections(content: string): ClaudeMdSection[] {
    const lines = content.split('\n');
    const sections: ClaudeMdSection[] = [];
    let currentSection: ClaudeMdSection | null = null;

    for (const line of lines) {
      const headerMatch = line.match(/^(#{1,6})\s+(.+)$/);
      
      if (headerMatch) {
        // Save previous section if exists
        if (currentSection) {
          currentSection.content = currentSection.content.trim();
          sections.push(currentSection);
        }

        // Start new section
        const level = headerMatch[1].length;
        const title = headerMatch[2].trim();
        const isAutoGenerated = this.isAutoGeneratedSection(title, line);

        currentSection = {
          title,
          content: '',
          isAutoGenerated,
          level
        };
      } else if (currentSection) {
        // Add content to current section
        currentSection.content += line + '\n';
      }
    }

    // Don't forget the last section
    if (currentSection) {
      currentSection.content = currentSection.content.trim();
      sections.push(currentSection);
    }

    return sections;
  }

  private isAutoGeneratedSection(title: string, line: string): boolean {
    const autoGeneratedMarkers = [
      'Auto-generated Configuration',
      'Claude Code Configuration',
      'Generated for:',
      'Coding Standards',
      'Architecture Guidelines',
      'Testing Requirements',
      'Simplicity Guardrails',
      'Verification Standards',
      'Compliance Protocols',
      'Important Reminders',
      'important-instruction-reminders',
      'MANDATORY COMPLIANCE PROTOCOL'
    ];

    return autoGeneratedMarkers.some(marker => 
      title.includes(marker) || line.includes(marker)
    );
  }

  /**
   * Generate project-specific content based on codebase analysis
   */
  generateProjectSpecificContent(
    projectAnalysis: any,
    userProfile: any,
    codebaseInfo: ProjectSpecificContent
  ): ClaudeMdSection[] {
    const sections: ClaudeMdSection[] = [];

    // Generate tailored coding standards
    const codingStandards = this.generateCodingStandards(codebaseInfo, userProfile);
    sections.push({
      title: 'Coding Standards',
      content: codingStandards.map(rule => `- ${rule}`).join('\n'),
      isAutoGenerated: true,
      level: 2
    });

    // Generate architecture guidelines
    const architectureGuidelines = this.generateArchitectureGuidelines(codebaseInfo, userProfile);
    sections.push({
      title: 'Architecture Guidelines',
      content: architectureGuidelines.map(rule => `- ${rule}`).join('\n'),
      isAutoGenerated: true,
      level: 2
    });

    // Generate testing requirements
    const testingRequirements = this.generateTestingRequirements(codebaseInfo, userProfile);
    sections.push({
      title: 'Testing Requirements',
      content: testingRequirements.map(rule => `- ${rule}`).join('\n'),
      isAutoGenerated: true,
      level: 2
    });

    // Generate simplicity guardrails
    const simplicityGuardrails = this.generateSimplicityGuardrails(codebaseInfo, userProfile);
    sections.push({
      title: 'Simplicity Guardrails',
      content: simplicityGuardrails.map(rule => `- ${rule}`).join('\n'),
      isAutoGenerated: true,
      level: 2
    });

    return sections;
  }

  private generateCodingStandards(codebaseInfo: ProjectSpecificContent, userProfile: any): string[] {
    const standards: string[] = [];

    // TypeScript specific
    if (codebaseInfo.dependencies.includes('typescript')) {
      standards.push('TypeScript strict mode with no implicit any - compile errors are failures');
      standards.push('Prefer type imports: `import type { Type } from \'module\'` for types only');
    }

    // n8n specific
    if (codebaseInfo.projectType === 'n8n-custom-node') {
      standards.push('n8n node development patterns: INodeType, INodeExecutionData, INodePropertyOptions');
      standards.push('Use n8n error classes: NodeApiError for API issues, NodeOperationError for logic errors');
      standards.push('Follow n8n\'s credential handling patterns using ICredentialType interface');
      standards.push('Use n8n\'s built-in helpers: this.helpers.httpRequest() instead of raw fetch/axios');
    }

    // CLI tool specific
    if (codebaseInfo.projectType === 'cli-tool') {
      standards.push('CLI tools need minimal architecture - avoid enterprise patterns');
      standards.push('Use commander.js or yargs patterns consistently for argument parsing');
      standards.push('Provide clear error messages with actionable suggestions');
    }

    // React specific
    if (codebaseInfo.frameworks.includes('react')) {
      standards.push('Use functional components with hooks over class components');
      standards.push('Prefer custom hooks for reusable stateful logic');
      standards.push('Use React.memo() for expensive components that re-render frequently');
    }

    // Testing frameworks
    if (codebaseInfo.testFrameworks.includes('vitest')) {
      standards.push('Use vitest for testing - leverage its speed and TypeScript integration');
    } else if (codebaseInfo.testFrameworks.includes('jest')) {
      standards.push('Use Jest testing patterns with describe/it blocks');
    }

    // Always include these fundamentals
    standards.push('ðŸš¨ FORBIDDEN: Making claims without evidence - all functionality claims need REAL test results');
    standards.push('Delete code before adding code - simpler is always better');
    standards.push('10-15 line functions maximum before mandatory refactoring');

    return standards;
  }

  private generateArchitectureGuidelines(codebaseInfo: ProjectSpecificContent, userProfile: any): string[] {
    const guidelines: string[] = [];

    // Project type specific architecture
    if (codebaseInfo.projectType === 'n8n-custom-node') {
      guidelines.push('Single responsibility per operation - no generic \'do everything\' operations');
      guidelines.push('Direct API calls using n8n helpers - avoid unnecessary abstraction layers');
      guidelines.push('Keep operation definitions flat - avoid deeply nested property structures');
    } else if (codebaseInfo.projectType === 'cli-tool') {
      guidelines.push('CLI tools need minimal architecture - avoid enterprise patterns');
      guidelines.push('Direct implementations over abstract factories/strategies');
      guidelines.push('One file per major concern - avoid micro-module proliferation');
    } else {
      guidelines.push('Direct implementations over abstract factories/strategies');
      guidelines.push('Composition over inheritance for extending functionality');
    }

    // Framework specific
    if (codebaseInfo.frameworks.includes('express')) {
      guidelines.push('Use Express middleware for cross-cutting concerns (auth, validation, logging)');
      guidelines.push('Structure routes with clear separation between controller logic and business logic');
    }

    // Always include YAGNI and simplicity
    guidelines.push('YAGNI: No caching layer unless specifically required by performance issues');
    guidelines.push('YAGNI: No retry logic beyond framework built-in capabilities');
    guidelines.push('No abstractions without demonstrable current need');
    guidelines.push('Configuration over code for variability');

    return guidelines;
  }

  private generateTestingRequirements(codebaseInfo: ProjectSpecificContent, userProfile: any): string[] {
    const requirements: string[] = [];

    // Always critical for external APIs
    requirements.push('ðŸš¨ CRITICAL: Mock-only tests are INADEQUATE and HIGH RISK for API integrations');

    // Project specific testing
    if (codebaseInfo.projectType === 'n8n-custom-node') {
      requirements.push('MANDATORY: Integration tests must make REAL API calls to external endpoints');
      requirements.push('MANDATORY: Create .env.test with real API credentials for testing');
      requirements.push('Each operation needs: unit tests for logic + integration tests with REAL API');
      requirements.push('Error scenarios must be tested with REAL API errors (401, 404, 500, etc.)');
    } else if (codebaseInfo.projectType === 'cli-tool') {
      requirements.push('CLI commands must be tested with real subprocess execution');
      requirements.push('File operations must be tested against real filesystem');
      requirements.push('Terminal output must be captured and verified in tests');
    }

    // Framework specific
    if (codebaseInfo.testFrameworks.includes('vitest')) {
      requirements.push('Use vitest\'s native async testing - avoid setTimeout in tests');
    }

    // Performance and evidence
    requirements.push('Performance claims require REAL measurements: response time, memory usage');
    requirements.push('Every external API call must have a corresponding REAL integration test');
    requirements.push('Every test must include actual output/response verification');

    return requirements;
  }

  private generateSimplicityGuardrails(codebaseInfo: ProjectSpecificContent, userProfile: any): string[] {
    const guardrails: string[] = [];

    // Project specific complexity limits
    if (codebaseInfo.projectType === 'cli-tool') {
      guardrails.push('Maximum 3 levels of indirection (caller â†’ function â†’ implementation)');
      guardrails.push('Inline simple logic rather than creating utility functions');
    } else if (codebaseInfo.projectType === 'n8n-custom-node') {
      guardrails.push('Operations should be 30-50 lines max - if longer, it\'s too complex');
      guardrails.push('No configuration files for values used in only one place');
    }

    // Framework specific
    if (codebaseInfo.frameworks.includes('react')) {
      guardrails.push('No Higher-Order Components - prefer composition and hooks');
      guardrails.push('Avoid render props patterns - use hooks for logic sharing');
    }

    // Universal simplicity rules
    guardrails.push('STOP and justify before adding any abstraction');
    guardrails.push('No future-proofing - solve today\'s problem only');
    guardrails.push('Prefer 50 lines of clear code over 20 lines of clever code');
    guardrails.push('Delete commented code immediately - git preserves history');
    guardrails.push('Question every interface, abstract class, and generic type');
    guardrails.push('No \'utility\' functions until used in 3+ places (Rule of Three)');

    return guardrails;
  }

  /**
   * Merge new sections with existing ones, avoiding duplicates
   */
  mergeWithExisting(newSections: ClaudeMdSection[]): void {
    for (const newSection of newSections) {
      const existingIndex = this.sections.findIndex(
        s => s.title === newSection.title && s.level === newSection.level
      );

      if (existingIndex >= 0) {
        // Replace existing auto-generated sections, preserve user sections
        const existing = this.sections[existingIndex];
        if (existing.isAutoGenerated) {
          // Merge rules to avoid pure replacement - keep unique user additions
          const mergedContent = this.mergeRuleContent(existing.content, newSection.content);
          this.sections[existingIndex] = {
            ...newSection,
            content: mergedContent
          };
        }
        // Keep user sections unchanged
      } else {
        // Add new section
        this.sections.push(newSection);
      }
    }
  }

  private mergeRuleContent(existingContent: string, newContent: string): string {
    const existingRules = this.parseRules(existingContent);
    const newRules = this.parseRules(newContent);
    
    // Combine and deduplicate rules
    const allRules = new Set([...existingRules, ...newRules]);
    return Array.from(allRules).join('\n');
  }

  private parseRules(content: string): string[] {
    return content
      .split('\n')
      .filter(line => line.trim().startsWith('- '))
      .map(line => line.trim());
  }

  /**
   * Generate the final CLAUDE.md content
   */
  generateFinalContent(
    userProfile: any,
    projectAnalysis: any
  ): string {
    let content = '';
    
    // Add header if doesn't exist
    const hasMainHeader = this.sections.some(s => s.title === 'CLAUDE.md' || s.title.includes('Claude Code Configuration'));
    if (!hasMainHeader) {
      content += `# Claude Code Configuration\n\n`;
      content += `Generated for: ${userProfile.role} (${userProfile.experience} level)\n`;
      content += `Project: ${projectAnalysis.projectType || 'detected project'} (${projectAnalysis.complexity} complexity)\n\n`;
    }

    // Group sections by level and add them in logical order
    const orderedSectionTitles = [
      'Project Overview',
      'Common Development Commands', 
      'Code Architecture',
      'Coding Standards',
      'Architecture Guidelines',
      'Testing Requirements',
      'Simplicity Guardrails',
      'Verification Standards',
      'Compliance Protocols',
      'Important Reminders',
      'important-instruction-reminders',
      'MANDATORY COMPLIANCE PROTOCOL'
    ];

    // Add sections in preferred order
    for (const sectionTitle of orderedSectionTitles) {
      const section = this.sections.find(s => s.title === sectionTitle);
      if (section) {
        content += `${'#'.repeat(section.level)} ${section.title}\n\n`;
        content += `${section.content}\n\n`;
      }
    }

    // Add any remaining sections not in the ordered list
    for (const section of this.sections) {
      if (!orderedSectionTitles.includes(section.title)) {
        content += `${'#'.repeat(section.level)} ${section.title}\n\n`;
        content += `${section.content}\n\n`;
      }
    }

    return content.trim();
  }

  /**
   * Save the merged content to file
   */
  async save(userProfile: any, projectAnalysis: any): Promise<void> {
    const content = this.generateFinalContent(userProfile, projectAnalysis);
    await writeFile(this.filePath, content, 'utf-8');
  }

  /**
   * Get sections for inspection/testing
   */
  getSections(): ClaudeMdSection[] {
    return [...this.sections];
  }
}